// Code generated by go-merge-types. DO NOT EDIT.

package outpkg

import (
	"fmt"
	"errors"

	
	pkg1 "github.com/forta-network/go-merge-types/example/pkg1"
	
	pkg2_2 "github.com/forta-network/go-merge-types/example/pkg2"
	
	pkg3 "github.com/forta-network/go-merge-types/example/pkg3"
	

	
	biggie "math/big"
	
	"math/big"
	
	"sync"
	
)

// Errors
var (
	ErrTagUnset       = errors.New("implementation tag is not set - please set it with Use() method before calling any methods")
	ErrNotImplemented = errors.New("method not implemented by source")
)

// Impl is a new type which can multiplex calls to different implementation types.
type Impl struct {
	
	typ0 *pkg1.Impl1
	
	typ1 *pkg2_2.Impl2
	
	typ2 *pkg3.Impl3
	
	currTag string
}

// NewImpl creates a new merged type.
func NewImpl(arg1 string, arg2 int, arg2Alt1 int64, arg3 *sync.WaitGroup, arg4 *pkg3.Foo) (*Impl, error) {
	var (
		mergedType Impl
		err error
	)

	
	mergedType.typ0, err = pkg1.NewImpl1(arg1, arg2)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize pkg1.Impl1: %v", err)
	}
	
	mergedType.typ1, err = pkg2_2.NewImpl2(arg2Alt1)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize pkg2_2.Impl2: %v", err)
	}
	
	mergedType.typ2, err = pkg3.NewImpl3(arg2, arg3, arg4)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize pkg3.Impl3: %v", err)
	}
	

	return &mergedType, nil
}

// Use sets the used implementation to given tag.
func (merged *Impl) Use(tag string) {
	merged.currTag = tag
}


// FooOutput is a merged return type.
type FooOutput struct {
	
	A string
	
	B float32
	
	FooResult *pkg2_2.Int
	
	FooResultAlt3 *big.Int
	
}

// BarOutput is a merged return type.
type BarOutput struct {
	
}



// Foo multiplexes to different implementations of the method.
func (merged *Impl) Foo(arg1 string, arg2 int, arg3 map[string]interface{}, arg3Alt2 *biggie.Int) (*FooOutput, error) {
	if merged.currTag == "" {
		return nil, ErrTagUnset
	}

	var retVal FooOutput

	
	if merged.currTag == "v0.0.1" {
		val, err := merged.typ0.Foo(arg1)
		
		if err != nil {
			return nil, err
		}
		
		
		retVal.A = val.A
		
		retVal.B = val.B
		
		return &retVal, nil
	}
	
	if merged.currTag == "v0.0.2" {
		val, err := merged.typ1.Foo(arg1, arg2, arg3)
		
		if err != nil {
			return nil, err
		}
		
		
		retVal.FooResult = val
		
		return &retVal, nil
	}
	
	if merged.currTag == "v0.0.3" {
		val, err := merged.typ2.Foo(arg2, arg3Alt2)
		
		if err != nil {
			return nil, err
		}
		
		
		retVal.FooResultAlt3 = val
		
		return &retVal, nil
	}
	

	return nil, fmt.Errorf("%w (tag=%s)", ErrNotImplemented, merged.currTag)
}

// Bar multiplexes to different implementations of the method.
func (merged *Impl) Bar(arg1 chan *string, arg1Alt4 map[string]interface{}) (*BarOutput, error) {
	if merged.currTag == "" {
		return nil, ErrTagUnset
	}

	var retVal BarOutput

	
	if merged.currTag == "v0.0.1" {
		merged.typ0.Bar(arg1)
		
		
		return &retVal, nil
	}
	
	if merged.currTag == "v0.0.3" {
		err := merged.typ2.Bar(arg1Alt4)
		
		if err != nil {
			return nil, err
		}
		
		
		return &retVal, nil
	}
	

	return nil, fmt.Errorf("%w (tag=%s)", ErrNotImplemented, merged.currTag)
}