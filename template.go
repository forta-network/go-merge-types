package merge

const codeTemplate = `
// Code generated by go-merge-types. DO NOT EDIT.

package {{.Output.Package}}

import (
	"fmt"
	"errors"

	{{range $source := .Sources}}
	{{$source.Package.Alias}} "{{$source.Package.ImportPath}}"
	{{end}}

	{{range $imp := .Output.Imports}}
	{{$imp}}
	{{end}}
)

// Errors
var (
	ErrTagUnset       = errors.New("implementation tag is not set - please set it with Use() method before calling any methods")
	ErrNotImplemented = errors.New("method not implemented by source")
)

// {{.Output.Type}} is a new type which can multiplex calls to different implementation types.
type {{.Output.Type}} struct {
	{{range $index, $source := .Sources}}
	typ{{$index}} *{{$source.Package.Alias}}.{{$source.Type}}
	{{end}}
	currTag string
}

// New{{.Output.Type}} creates a new merged type.
func New{{.Output.Type}}({{range $index, $arg := .Output.InitArgs}}{{if eq $index 0}}{{else}}, {{end}}{{$arg.Name}} {{$arg.Type}}{{end}}) (*{{.Output.Type}}, error) {
	var (
		mergedType {{.Output.Type}}
		err error
	)

	{{range $sourceIndex, $source := .Sources}}
	mergedType.typ{{$sourceIndex}}, err = {{$source.Package.Alias}}.New{{$source.Type}}({{range $argIndex, $arg := $source.InitArgs}}{{if eq $argIndex 0}}{{else}}, {{end}}{{$arg.Name}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("failed to initialize {{$source.Package.Alias}}.{{$source.Type}}: %v", err)
	}
	{{end}}

	return &mergedType, nil
}

// Use sets the used implementation to given tag.
func (merged *{{.Output.Type}}) Use(tag string) {
	merged.currTag = tag
}

{{range $method := .Output.Methods}}
// {{$method.ReturnType.Name}} is a merged return type.
type {{$method.ReturnType.Name}} struct {
	{{range $retField := $method.ReturnType.Fields}}
	{{$retField.Name}} {{$retField.Type}}
	{{end}}
}
{{end}}

{{range $method := .Output.Methods}}
// {{$method.Name}} multiplexes to different implementations of the method.
func (merged *{{$.Output.Type}}) {{$method.Name}}({{range $index, $arg := $method.Args}}{{if eq $index 0}}{{else}}, {{end}}{{$arg.Name}} {{$arg.Type}}{{end}}) (*{{$method.ReturnType.Name}}, error) {
	if merged.currTag == "" {
		return nil, ErrTagUnset
	}

	var retVal {{$method.ReturnType.Name}}

	{{range $variation := $method.Variations}}
	if merged.currTag == "{{$variation.Tag}}" {
		{{if $variation.NoReturn}}{{else}}{{if $variation.OnlyError}}err := {{else}}val, err := {{end}}{{end}}merged.typ{{$variation.SourceIndex}}.{{$method.Name}}({{range $index, $arg := $variation.Args}}{{if eq $index 0}}{{else}}, {{end}}{{$arg.Name}}{{end}})
		{{if eq $variation.NoReturn false}}
		if err != nil {
			return nil, err
		}
		{{end}}
		{{range $retField := $variation.ReturnedFields}}
		retVal.{{$retField.Name}} = val{{if $variation.MergeReturnedStruct}}.{{$retField.Name}}{{else}}{{end}}
		{{end}}
		return &retVal, nil
	}
	{{end}}

	return nil, fmt.Errorf("%w (tag=%s)", ErrNotImplemented, merged.currTag)
}
{{end}}
`
